//|-----------------------------------------------------------------------------------------|
//|                                                              Forex_Envy_v2.1_SqLite.mq4 |
//|                                                            Copyright © 2012, Dennis Lee |
//| Assert History                                                                          |
//| 1.11    Fixed minor bug in ChickenOutClose.                                             |
//| 1.10    Added PlusGhost.                                                                |
//| 1.00    Generated by EX4 TO MQ4 decompile Service.                                      |
//|-----------------------------------------------------------------------------------------|
#property copyright "Copyright © 2012, Dennis Lee"
#property link      ""

//#include <stdlib.mqh>
#import "stdlib.ex4"
   string ErrorDescription(int a0);
#import "forexenvy2.1.dll"
   int fun0(double& a0[], double& a1[], int a2, int a3, double a4, double& a5[], double a6, int a7);
   int fun1(string& a0[], int a1, double a2, string a3, int a4);
#import

//--- Assert 2: Plus include files
#include <PlusTurtle.mqh>
#include <PlusGhost.mqh>
int   MaxAccountTrades = 30;

int gi_76;
string gs_dummy_80;
string gsa_92[4] = {"0000000000", "1111111111", "2222222222", "33333333333"};
extern string User = "";
extern string KEY = "";
extern string _________ = "Input a unique magic number for each chart";
extern int MagicNumber = 0;
extern double BaseLotSize = 0.0;
extern int ExecutionPoint = 0;
extern double BasketTakeProfit = 0.0;
extern int BasketStopLoss = 0;
extern double Multiplier = 0.0;
extern int MaximumBuyLevels = 0;
extern int MaximumSellLevels = 0;
extern int Slippage = 0;
string gs_168 = "1234567890123456";
extern bool SupportECN = TRUE;
extern double BailOutPct = 0.0;
extern bool Chicken_Out = FALSE;
extern int Close_Order_Attempts = 3;
extern bool FreezeAfterTP = FALSE;
extern bool FreezeAfterTPScheduler = TRUE;
extern string __________ = "Freeze After TP Scheduler";
extern int SUN_StartHour = 0;
extern int SUN_StartMinute = 0;
extern int SUN_EndHour = 0;
extern int SUN_EndMinute = 0;
extern int MON_StartHour = 0;
extern int MON_StartMinute = 0;
extern int MON_EndHour = 0;
extern int MON_EndMinute = 0;
extern int TUE_StartHour = 0;
extern int TUE_StartMinute = 0;
extern int TUE_EndHour = 0;
extern int TUE_EndMinute = 0;
extern int WED_StartHour = 0;
extern int WED_StartMinute = 0;
extern int WED_EndHour = 0;
extern int WED_EndMinute = 0;
extern int THU_StartHour = 0;
extern int THU_StartMinute = 0;
extern int THU_EndHour = 0;
extern int THU_EndMinute = 0;
extern int FRI_StartHour = 0;
extern int FRI_StartMinute = 0;
extern int FRI_EndHour = 0;
extern int FRI_EndMinute = 0;
extern int SAT_StartHour = 0;
extern int SAT_StartMinute = 0;
extern int SAT_EndHour = 0;
extern int SAT_EndMinute = 0;
extern string EA_Name = "Forex Envy";
extern string ____________ = "";
extern string EnvyAugmenter = "";
extern string Level_1 = "";
extern double Multiplier_1 = 0.0;
extern double BasketTakeProfit_1 = 0.0;
extern string Level_2 = "";
extern double Multiplier_2 = 0.0;
extern double BasketTakeProfit_2 = 0.0;
extern string Level_3 = "";
extern double Multiplier_3 = 0.0;
extern double BasketTakeProfit_3 = 0.0;
extern string Level_4 = "";
extern double Multiplier_4 = 0.0;
extern double BasketTakeProfit_4 = 0.0;
extern string Level_5 = "";
extern double Multiplier_5 = 0.0;
extern double BasketTakeProfit_5 = 0.0;
extern string Level_6 = "";
extern double Multiplier_6 = 0.0;
extern double BasketTakeProfit_6 = 0.0;
extern string Level_7 = "";
extern double Multiplier_7 = 0.0;
extern double BasketTakeProfit_7 = 0.0;
extern string Level_8 = "";
extern double Multiplier_8 = 0.0;
extern double BasketTakeProfit_8 = 0.0;
extern string Level_9 = "";
extern double Multiplier_9 = 0.0;
extern double BasketTakeProfit_9 = 0.0;
extern string Level_10 = "";
extern double Multiplier_10 = 0.0;
extern double BasketTakeProfit_10 = 0.0;
extern string Level_11 = "";
extern double Multiplier_11 = 0.0;
extern double BasketTakeProfit_11 = 0.0;
extern string Level_12 = "";
extern double Multiplier_12 = 0.0;
extern double BasketTakeProfit_12 = 0.0;
extern string Level_13 = "";
extern double Multiplier_13 = 0.0;
extern double BasketTakeProfit_13 = 0.0;
extern string Level_14 = "";
extern double Multiplier_14 = 0.0;
extern double BasketTakeProfit_14 = 0.0;
extern string Level_15 = "";
extern double Multiplier_15 = 0.0;
extern double BasketTakeProfit_15 = 0.0;
extern string Level_16 = "";
extern double Multiplier_16 = 0.0;
extern double BasketTakeProfit_16 = 0.0;
extern string Level_17 = "";
extern double Multiplier_17 = 0.0;
extern double BasketTakeProfit_17 = 0.0;
extern string Level_18 = "";
extern double Multiplier_18 = 0.0;
extern double BasketTakeProfit_18 = 0.0;
extern string Level_19 = "";
extern double Multiplier_19 = 0.0;
extern double BasketTakeProfit_19 = 0.0;
extern string Level_20 = "";
extern double Multiplier_20 = 0.0;
extern double BasketTakeProfit_20 = 0.0;
extern string Level_21 = "";
extern double Multiplier_21 = 0.0;
extern double BasketTakeProfit_21 = 0.0;
extern string Level_22 = "";
extern double Multiplier_22 = 0.0;
extern double BasketTakeProfit_22 = 0.0;
extern string Level_23 = "";
extern double Multiplier_23 = 0.0;
extern double BasketTakeProfit_23 = 0.0;
extern string Level_24 = "";
extern double Multiplier_24 = 0.0;
extern double BasketTakeProfit_24 = 0.0;
extern string Level_25 = "";
extern double Multiplier_25 = 0.0;
extern double BasketTakeProfit_25 = 0.0;
double gd_948;
bool gi_956 = FALSE;
bool gi_960 = FALSE;
double gd_964;
double g_pips_972 = 0.0;
int gi_unused_980 = 0;
int gi_984 = 0;
int gi_unused_988 = 300;
int gi_992 = 5000;
int gi_996 = 0;
int gi_1000 = 0;
double gd_1004 = 100.0;
int gi_1012 = 600;
double gd_1016;
bool gi_1024;
int g_period_1028 = 7;
int gi_1032 = 0;
int g_ma_method_1036 = MODE_LWMA;
int g_applied_price_1040 = PRICE_WEIGHTED;
double gd_1044 = 0.25;
double gd_1052 = 0.2;
double gd_1060 = 1.01;
int gi_1068 = 5;
int g_datetime_1072;
double gd_1076;
int gi_1084;
bool gi_unused_1088 = FALSE;
string gs_dummy_1092;
int gi_unused_1108 = 0;
int gi_unused_1112 = 1;
int gi_unused_1116 = 3;
int gi_unused_1120 = 250;
string gs_1124;
bool gi_1132;
bool gi_1136;
bool gi_1140;
bool gi_1144;
int g_ticket_1148;
int g_cmd_1152;
string gs__hedged_1156 = " hedged";
int gi_1164;
bool gi_1168 = FALSE;
string gs_1172 = "12345678901234567890123456789012345678901234567890ABCDEFGHIJKLMNOP";
double gda_1180[27];
double gda_1184[27];
double gda_1196[4];
int gi_1200;
double g_point_1204 = 0.0001;
bool gi_1212 = FALSE;
int gia_1216[25];
int gia_1220[25];
double gda_1224[25];
double gda_1228[25];
double gda_1232[25];
double gda_1236[25];
int g_error_1248;

void f0_16(string as_unused_0) {
   if (gi_1164 >= 0) {
   }
}

void f0_10() {
   gd_948 = 0;
//--- Assert 2: Init OrderSelect #1
   int hist_total_0 = GhostOrdersHistoryTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_HISTORY);
   for (int pos_4 = 0; pos_4 < hist_total_0; pos_4++) {
      GhostOrderSelect(pos_4, SELECT_BY_POS, MODE_HISTORY);
      if (GhostOrderMagicNumber() == MagicNumber) gd_948 += GhostOrderProfit() + GhostOrderSwap();
   }
//--- Assert 1: Free OrderSelect #1
   GhostFreeSelect(false);
}

int f0_5() {
   double ld_0 = MarketInfo(Symbol(), MODE_MINLOT);
   for (int count_8 = 0; ld_0 < 1.0; count_8++) ld_0 = 10.0 * ld_0;
   return (count_8);
}

double f0_2(double a_minlot_0) {
   double minlot_8;
   double ld_16 = GhostAccountEquity() - gi_992;
   double ld_24 = gi_996;
   double ld_32 = gi_1000;
   if (gi_996 == 0 || gi_1000 == 0) minlot_8 = a_minlot_0;
   else {
      ld_24 = gi_992 * ld_24 / 100.0;
      Print("tmp=" + ld_16 + ",AccountEquity()=" + GhostAccountEquity() + ",InitEquity=" + gi_992);
      ld_32 /= 100.0;
      if (ld_16 > 0.0) ld_16 = MathPow(ld_32 + 1.0, ld_16 / ld_24);
      else {
         if (ld_16 < 0.0) ld_16 = MathPow(1 - ld_32, MathAbs(ld_16 / ld_24));
         else ld_16 = 1;
      }
      minlot_8 = NormalizeDouble(a_minlot_0 * ld_16, f0_5());
      if (minlot_8 < MarketInfo(Symbol(), MODE_MINLOT)) minlot_8 = MarketInfo(Symbol(), MODE_MINLOT);
   }
   if (minlot_8 < 0.0) Print("ERROR tmp=" + ld_16 + ",a=" + ld_24 + ",b=" + ld_32 + ",AccountEquity()=" + GhostAccountEquity());
   return (minlot_8);
}

int deinit() {
//--- Assert 2: DeInit Plus
   GhostDeInit();
   Comment("");
   ObjectDelete("Buy_Target");
   ObjectDelete("Buy_StopLoss");
   ObjectDelete("Sell_Target");
   ObjectDelete("Sell_StopLoss");
   return (0);
}

int f0_8() {
   bool bool_4;
   double ld_12;
   int li_20;
   bool li_ret_0 = FALSE;
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #2
   int   total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_8 = total - 1; pos_8 >= 0; pos_8--) {
      if (GhostOrderSelect(pos_8, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderSymbol() == Symbol()) {
            RefreshRates();
            if (GhostOrderType() == OP_BUY) {
               if (GhostOrderStopLoss() == 0.0) {
                  ld_12 = GhostOrderOpenPrice() - gi_984 * Point;
                  li_20 = Close_Order_Attempts;
                  bool_4 = FALSE;
                  while (bool_4 == FALSE && li_20 >= 0) {
                     li_20--;
                     RefreshRates();
                  //--- 5: Assert replace OrderModify a buy trade with arrays
                     aCommand[aCount]     = 1; 
                     aStopLoss[aCount]    = ld_12;
                     aCount ++;
                     if( aCount >= MaxAccountTrades ) break;
                     /*bool_4 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(ld_12, Digits), OrderTakeProfit(), 0, Black);*/
                     if (!TRUE) {
                        g_error_1248 = GetLastError();
                        if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                           Sleep(50);
                           continue;
                        }
                     }
                     bool_4 = TRUE;
                  }
               }
            }
            if (GhostOrderType() == OP_SELL) {
               if (GhostOrderStopLoss() == 0.0) {
                  ld_12 = GhostOrderOpenPrice() + gi_984 * Point;
                  li_20 = Close_Order_Attempts;
                  bool_4 = FALSE;
                  while (bool_4 == FALSE && li_20 >= 0) {
                     li_20--;
                     RefreshRates();
                  //--- 5: Assert replace OrderModify a sell trade with arrays
                     aCommand[aCount]     = 3; 
                     aStopLoss[aCount]    = ld_12;
                     aCount ++;
                     if( aCount >= MaxAccountTrades ) break;
                     /*bool_4 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(ld_12, Digits), OrderTakeProfit(), 0, Black);*/
                     if (!TRUE) {
                        g_error_1248 = GetLastError();
                        if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                           Sleep(50);
                           continue;
                        }
                     }
                     bool_4 = TRUE;
                  }
               }
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #2
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
            GhostOrderModify( aTicket[i], NormalizeDouble(aOpenPrice[i],Digits), NormalizeDouble(aStopLoss[i],Digits), aTakeProfit[i], 0, Black );         
            break;
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
            GhostOrderModify( aTicket[i], NormalizeDouble(aOpenPrice[i],Digits), NormalizeDouble(aStopLoss[i],Digits), aTakeProfit[i], 0, Black );         
            break;
         case 4:  // OrderClose Sell
            break;
      }
   }
   return (li_ret_0);
}

int init() {
   gi_1212 = FALSE;
   if (Chicken_Out == TRUE) gi_960 = TRUE;
   else gi_960 = FALSE;
   if (Period() != PERIOD_M30) {
      Print("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
      Alert("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
   }
   gsa_92[0] = GhostAccountNumber();
   gsa_92[1] = KEY;
   gsa_92[2] = User;
   gsa_92[3] = gs_168;
   gi_76 = fun1(gsa_92, ArraySize(gsa_92), 0.1, gs_1172, IsDemo());
   gd_964 = Multiplier;
   if (Digits == 3) {
      gi_unused_980 = 10.0 * ExecutionPoint;
      gi_984 = 10.0 * BasketStopLoss;
      g_point_1204 = 0.01;
   } else {
      if (Digits == 5) {
         gi_unused_980 = 10.0 * ExecutionPoint;
         gi_984 = 10.0 * BasketStopLoss;
         g_point_1204 = 0.0001;
      } else {
         gi_unused_980 = ExecutionPoint;
         gi_984 = BasketStopLoss;
         g_point_1204 = Point;
      }
   }
   gda_1180[0] = BasketTakeProfit_1;
   gda_1180[1] = BasketTakeProfit_2;
   gda_1180[2] = BasketTakeProfit_3;
   gda_1180[3] = BasketTakeProfit_4;
   gda_1180[4] = BasketTakeProfit_5;
   gda_1180[5] = BasketTakeProfit_6;
   gda_1180[6] = BasketTakeProfit_7;
   gda_1180[7] = BasketTakeProfit_8;
   gda_1180[8] = BasketTakeProfit_9;
   gda_1180[9] = BasketTakeProfit_10;
   gda_1180[10] = BasketTakeProfit_11;
   gda_1180[11] = BasketTakeProfit_12;
   gda_1180[12] = BasketTakeProfit_13;
   gda_1180[13] = BasketTakeProfit_14;
   gda_1180[14] = BasketTakeProfit_15;
   gda_1180[15] = BasketTakeProfit_16;
   gda_1180[16] = BasketTakeProfit_17;
   gda_1180[17] = BasketTakeProfit_18;
   gda_1180[18] = BasketTakeProfit_19;
   gda_1180[19] = BasketTakeProfit_20;
   gda_1180[20] = BasketTakeProfit_21;
   gda_1180[21] = BasketTakeProfit_22;
   gda_1180[22] = BasketTakeProfit_23;
   gda_1180[23] = BasketTakeProfit_24;
   gda_1180[24] = BasketTakeProfit_25;
   gda_1180[25] = BasketTakeProfit;
   gda_1180[26] = BasketTakeProfit_1;
   gda_1184[0] = Multiplier_1;
   gda_1184[1] = Multiplier_2;
   gda_1184[2] = Multiplier_3;
   gda_1184[3] = Multiplier_4;
   gda_1184[4] = Multiplier_5;
   gda_1184[5] = Multiplier_6;
   gda_1184[6] = Multiplier_7;
   gda_1184[7] = Multiplier_8;
   gda_1184[8] = Multiplier_9;
   gda_1184[9] = Multiplier_10;
   gda_1184[10] = Multiplier_11;
   gda_1184[11] = Multiplier_12;
   gda_1184[12] = Multiplier_13;
   gda_1184[13] = Multiplier_14;
   gda_1184[14] = Multiplier_15;
   gda_1184[15] = Multiplier_16;
   gda_1184[16] = Multiplier_17;
   gda_1184[17] = Multiplier_18;
   gda_1184[18] = Multiplier_19;
   gda_1184[19] = Multiplier_20;
   gda_1184[20] = Multiplier_21;
   gda_1184[21] = Multiplier_22;
   gda_1184[22] = Multiplier_23;
   gda_1184[23] = Multiplier_24;
   gda_1184[24] = Multiplier_25;
   gda_1184[25] = Multiplier;
   gda_1184[26] = Multiplier_1;
   int li_0 = fun0(gda_1180, gda_1184, Digits, 0, Point, gda_1196, 0, IsDemo());
   if (li_0 >= 0) {
      g_pips_972 = gda_1196[0];
      gd_1076 = gda_1196[1];
      gd_964 = gda_1196[2];
   }
   gi_1084 = MathRound((-MathLog(MarketInfo(Symbol(), MODE_LOTSTEP))) / 2.302585093);
   gi_1132 = FALSE;
   gi_1136 = FALSE;
   gi_1140 = FALSE;
   gi_1144 = FALSE;
   g_ticket_1148 = -1;
   gi_1024 = FALSE;
   g_cmd_1152 = -1;
   gs_1124 = "approved";
   if (gi_76 == 0) {
      Print("Please input valid KEY.");
      Alert("Please input valid KEY.");
   }
//--- Assert 2: Init Plus   
   TurtleInit();
   GhostInit();
   return (0);
}

double f0_11(int ai_0) {
//--- Assert 4: Init OrderSelect #3
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #3
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

double f0_3(int ai_0) {
//--- Assert 4: Init OrderSelect #4
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_BUY) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #4
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

double f0_6(int ai_0) {
//--- Assert 4: Init OrderSelect #5
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_SELL) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #5
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

int f0_12(bool ai_0 = FALSE) {
   int ticket_4;
   double lots_8;
   int li_48;
   bool bool_52;
   double ld_16 = 0;
   double ld_24 = 0;
   string ls_32 = "";
   bool li_ret_40 = TRUE;
   if (TimeCurrent() - g_datetime_1072 < 60) return (0);
   if (ai_0 && (!gi_1140)) return (0);
   if (!GlobalVariableCheck("PERMISSION")) {
      GlobalVariableSet("PERMISSION", TimeCurrent());
      if (!SupportECN) {
         if (ai_0) {
         //--- Assert 4: Init OrderSelect #6
            GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
            if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) 
            {
               ld_24 = GhostOrderTakeProfit() - MarketInfo(Symbol(), MODE_SPREAD) * Point;
            }
         //--- Assert 2: Free OrderSelect #6
            GhostFreeSelect(false);
         } else ld_16 = Ask + g_pips_972 * Point;
      }
      if (gi_1168 == FALSE) {
         if (ai_0) lots_8 = NormalizeDouble(f0_11(1) * gd_1060, 2);
         else lots_8 = f0_2(gd_1016);
      } else {
         if (f0_3(0) > 0.0) lots_8 = NormalizeDouble(f0_3(0) * gd_964, 2);
         else lots_8 = NormalizeDouble(BaseLotSize, 2);
      }
      if (BasketStopLoss > 0) ld_24 = Ask - gi_984 * Point;
      if (!SupportECN) {
         if (ld_16 == 0.0) ld_16 = Ask + BasketTakeProfit * g_point_1204;
         if (ld_24 == 0.0) ld_24 = Ask - BasketStopLoss * g_point_1204;
         if (gi_1212 == TRUE) {
            for (int index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
                  MagicNumber, 0, Green);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 0;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Ask, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
               MagicNumber, 0, Green);
         }
      } else {
         if (gi_1212 == TRUE) {
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Green);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 0;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Ask, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
               Sleep(1000);
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Green);
            Sleep(1000);
         }
         if (ticket_4 >= 0) {
         //--- Assert 1: Declare variables
            double   aOpenPrice;
         //--- Assert 2: Init OrderSelect #7
            GhostInitSelect(true,ticket_4,SELECT_BY_TICKET,MODE_TRADES);
            if( GhostOrderSelect(ticket_4, SELECT_BY_TICKET) ) aOpenPrice = GhostOrderOpenPrice();
         //--- Assert 1: Free OrderSelect #7
            GhostFreeSelect(false);
            if (ld_16 == 0.0) ld_16 = Ask + BasketTakeProfit * g_point_1204;
            if (ld_24 == 0.0) ld_24 = Ask - BasketStopLoss * g_point_1204;
            li_48 = Close_Order_Attempts;
            bool_52 = FALSE;
            while (bool_52 == FALSE && li_48 >= 0) {
               li_48--;
               RefreshRates();
               bool_52 = GhostOrderModify(ticket_4, NormalizeDouble(aOpenPrice, Digits), NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), 0, Black);
               if (!bool_52) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_52 = TRUE;
            }
         }
      }
      g_datetime_1072 = TimeCurrent();
      if (ticket_4 != -1) {
         if (!ai_0) {
            g_ticket_1148 = ticket_4;
            f0_16("BUY hedgedTicket=" + g_ticket_1148);
         } else {
            f0_16("BUY Envy_ticket=" + ticket_4);
            g_cmd_1152 = 0;
         }
      } else {
         f0_16("failed sell");
         li_ret_40 = FALSE;
      }
   }
   GlobalVariableDel("PERMISSION");
   return (li_ret_40);
}

int f0_13(bool ai_0 = FALSE) {
   int ticket_4;
   double lots_8;
   int li_48;
   bool bool_52;
   double ld_16 = 0;
   double ld_24 = 0;
   string ls_32 = "";
   bool li_ret_40 = TRUE;
   if (TimeCurrent() - g_datetime_1072 < 60) return (0);
   if (ai_0 && (!gi_1144)) return (0);
   if (!GlobalVariableCheck("PERMISSION")) {
      GlobalVariableSet("PERMISSION", TimeCurrent());
      if (!SupportECN) {
         if (ai_0) {
         //--- Assert 4: Init OrderSelect #8
            GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
            if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) 
            {
               ld_24 = GhostOrderTakeProfit() + MarketInfo(Symbol(), MODE_SPREAD) * Point;
            }
         //--- Assert 2: Free OrderSelect #8
            GhostFreeSelect(false);
         } else ld_16 = Bid - g_pips_972 * Point;
      }
      if (gi_1168 == FALSE) {
         if (ai_0) lots_8 = NormalizeDouble(f0_11(0) * gd_1060, 2);
         else lots_8 = f0_2(gd_1016);
      } else {
         if (f0_6(0) > 0.0) lots_8 = NormalizeDouble(f0_6(0) * gd_964, 2);
         else lots_8 = NormalizeDouble(BaseLotSize, 2);
      }
      if (BasketStopLoss > 0) ld_24 = Bid + gi_984 * Point;
      if (!SupportECN) {
         if (ld_16 == 0.0) ld_16 = Bid - BasketTakeProfit * g_point_1204;
         if (ld_24 == 0.0) ld_24 = Bid + BasketStopLoss * g_point_1204;
         if (gi_1212 == TRUE) {
            for (int index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
                  MagicNumber, 0, Pink);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 1;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Bid, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
               MagicNumber, 0, Pink);
         }
      } else {
         if (gi_1212 == TRUE) {
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Pink);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 1;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Bid, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
               Sleep(1000);
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Pink);
            Sleep(1000);
         }
         if (ticket_4 >= 0) {
         //--- Assert 1: Declare variables
            double   aOpenPrice;
         //--- Assert 2: Init OrderSelect #9
            GhostInitSelect(true,ticket_4,SELECT_BY_TICKET,MODE_TRADES);
            if( GhostOrderSelect(ticket_4, SELECT_BY_TICKET) ) aOpenPrice = GhostOrderOpenPrice();
         //--- Assert 1: Free OrderSelect #9
            GhostFreeSelect(false);
            if (ld_16 == 0.0) ld_16 = Bid - BasketTakeProfit * g_point_1204;
            if (ld_24 == 0.0) ld_24 = Bid + BasketStopLoss * g_point_1204;
            li_48 = Close_Order_Attempts;
            bool_52 = FALSE;
            while (bool_52 == FALSE && li_48 >= 0) {
               li_48--;
               RefreshRates();
               bool_52 = GhostOrderModify(ticket_4, NormalizeDouble(aOpenPrice, Digits), NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), 0, Black);
               if (!bool_52) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_52 = TRUE;
            }
         }
      }
      g_datetime_1072 = TimeCurrent();
      if (ticket_4 != -1) {
         if (!ai_0) {
            g_ticket_1148 = ticket_4;
            f0_16("SELL hedgedTicket=" + g_ticket_1148);
         } else {
            f0_16("SELL Envy_ticket=" + ticket_4);
            g_cmd_1152 = 1;
         }
      } else {
         f0_16("failed sell");
         li_ret_40 = FALSE;
      }
   }
   GlobalVariableDel("PERMISSION");
   return (li_ret_40);
}

void f0_15(int ai_0, int ai_unused_4) {
   int li_64;
   bool bool_68;
   int datetime_8 = 0;
   double order_open_price_12 = 0;
   double order_lots_20 = 0;
   double order_takeprofit_28 = 0;
   double order_stoploss_36 = 0;
   int cmd_44 = -1;
   int ticket_48 = 0;
   int pos_52 = 0;
   int count_56 = 0;
//--- Assert 2: Init OrderSelect #10
   int   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_BUY) {
            count_56++;
            if (GhostOrderOpenTime() > datetime_8) {
               datetime_8 = GhostOrderOpenTime();
               order_open_price_12 = GhostOrderOpenPrice();
               cmd_44 = GhostOrderType();
               ticket_48 = GhostOrderTicket();
               order_takeprofit_28 = GhostOrderTakeProfit();
               order_stoploss_36 = GhostOrderStopLoss();
            }
            if (GhostOrderLots() > order_lots_20) order_lots_20 = GhostOrderLots();
         }
      }
   }
//--- Assert 1: Free OrderSelect #10
   GhostFreeSelect(false);
   int li_60 = MathRound(MathLog(order_lots_20 / BaseLotSize) / MathLog(gd_964)) + 1.0;
   if (li_60 < 0) li_60 = 0;
   gd_1016 = NormalizeDouble(BaseLotSize * MathPow(gd_964, li_60), gi_1084);
   if (li_60 == 0 && f0_7() == 1) {
      if (FreezeAfterTP == FALSE && gi_956 == FALSE) f0_12();
      else
         if (ai_0 > 0) f0_12();
   } else {
      if (order_open_price_12 - Ask > ExecutionPoint * gd_1076 && order_open_price_12 > 0.0 && count_56 < MaximumBuyLevels) {
         if (!(f0_12())) return;
         return;
      }
   }
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #11
   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if( GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES) )
      {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() != MagicNumber || GhostOrderType() != OP_BUY || GhostOrderStopLoss() == order_stoploss_36 || order_stoploss_36 == 0.0 || GhostOrderTakeProfit() == order_takeprofit_28 ||
            order_takeprofit_28 == 0.0) continue;
         li_64 = Close_Order_Attempts;
         bool_68 = FALSE;
         while (bool_68 == FALSE && li_64 >= 0) {
            li_64--;
            RefreshRates();
         //--- 6: Assert replace OrderModify a buy trade with arrays
            aCommand[aCount]     = 1; 
            aOpenPrice[aCount]   = NormalizeDouble(GhostOrderOpenPrice(), Digits);
            aStopLoss[aCount]    = NormalizeDouble(order_stoploss_36, Digits);
            aTakeProfit[aCount]  = NormalizeDouble(order_takeprofit_28, Digits);
            aCount ++;
            if( aCount >= MaxAccountTrades ) break;
            /*bool_68 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(order_stoploss_36, Digits), NormalizeDouble(order_takeprofit_28, Digits),
               0, Pink);*/
            if (!TRUE) {
               g_error_1248 = GetLastError();
               if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                  Sleep(50);
                  continue;
               }
            }
            bool_68 = TRUE;
         }
         Sleep(1000);
      }
   }
//--- Assert 1: Free OrderSelect #11
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
            GhostOrderModify( aTicket[i], aOpenPrice[i], aStopLoss[i], aTakeProfit[i], 0, Pink ); 
            break;
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
         case 4:  // OrderClose Sell
            break;
      }
   }
}

int f0_7() {
   double isar_0 = iSAR(NULL, PERIOD_H1, gd_1044, gd_1052, 0);
   double ima_8 = iMA(NULL, PERIOD_H1, g_period_1028, gi_1032, g_ma_method_1036, g_applied_price_1040, 0);
   if (isar_0 > ima_8) return (-1);
   if (isar_0 < ima_8) return (1);
   return (0);
}

void f0_14(int ai_unused_0, int ai_4) {
   int li_64;
   bool bool_68;
   int datetime_8 = 0;
   double order_open_price_12 = 0;
   double order_lots_20 = 0;
   double order_takeprofit_28 = 0;
   double order_stoploss_36 = 0;
   int cmd_44 = -1;
   int ticket_48 = 0;
   int pos_52 = 0;
   int count_56 = 0;
//--- Assert 2: Init OrderSelect #12
   int   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_SELL) {
            count_56++;
            if (GhostOrderOpenTime() > datetime_8) {
               datetime_8 = GhostOrderOpenTime();
               order_open_price_12 = GhostOrderOpenPrice();
               cmd_44 = GhostOrderType();
               ticket_48 = GhostOrderTicket();
               order_takeprofit_28 = GhostOrderTakeProfit();
               order_stoploss_36 = GhostOrderStopLoss();
            }
            if (GhostOrderLots() > order_lots_20) order_lots_20 = GhostOrderLots();
         }
      }
   }
//--- Assert 1: Free OrderSelect #12
   GhostFreeSelect(false);
   int li_60 = MathRound(MathLog(order_lots_20 / BaseLotSize) / MathLog(gd_964)) + 1.0;
   if (li_60 < 0) li_60 = 0;
   gd_1016 = NormalizeDouble(BaseLotSize * MathPow(gd_964, li_60), gi_1084);
   if (li_60 == 0 && f0_7() == -1) {
      if (FreezeAfterTP == FALSE && gi_956 == FALSE) f0_13();
      else
         if (ai_4 > 0) f0_13();
   } else {
      if (Bid - order_open_price_12 > ExecutionPoint * gd_1076 && order_open_price_12 > 0.0 && count_56 < MaximumSellLevels) {
         if (!(f0_13())) return;
         return;
      }
   }
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #13
   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_SELL) {
            if (GhostOrderTakeProfit() == order_takeprofit_28 || GhostOrderStopLoss() == order_stoploss_36 || order_stoploss_36 == 0.0 || order_takeprofit_28 == 0.0) continue;
            li_64 = Close_Order_Attempts;
            bool_68 = FALSE;
            while (bool_68 == FALSE && li_64 >= 0) {
               li_64--;
               RefreshRates();
            //--- 6: Assert replace OrderModify a buy trade with arrays
               aCommand[aCount]     = 3; 
               aOpenPrice[aCount]   = NormalizeDouble(GhostOrderOpenPrice(), Digits);
               aStopLoss[aCount]    = NormalizeDouble(order_stoploss_36, Digits);
               aTakeProfit[aCount]  = NormalizeDouble(order_takeprofit_28, Digits);
               aCount ++;
               if( aCount >= MaxAccountTrades ) break;
               /*bool_68 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(order_stoploss_36, Digits), NormalizeDouble(order_takeprofit_28, Digits),
                  0, Pink);*/
               if (!TRUE) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_68 = TRUE;
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #13
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
            GhostOrderModify( aTicket[i], aOpenPrice[i], aStopLoss[i], aTakeProfit[i], 0, Pink ); 
            break;
         case 4:  // OrderClose Sell
            break;
      }
   }
}

int ChickenOutClose(string a_symbol_0) {
   int ticket_20;
   int li_12 = 0;
   bool is_closed_16 = FALSE;
   int error_24 = 0;
   int order_total_28 = GhostOrdersTotal();
   if (order_total_28 == 0) return (0);
   double ld_unused_32 = 0;
//--- Assert 6: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aLots[];
   double   aClosePrice[];
   bool     aOk[];
   int      aCount;
//--- Assert 5: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aLots,MaxAccountTrades);
   ArrayResize(aClosePrice,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #14
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_40 = order_total_28 - 1; pos_40 >= 0; pos_40--) {
      if (GhostOrderSelect(pos_40, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aLots[aCount]        =  GhostOrderLots();
         aClosePrice[aCount]  =  GhostOrderClosePrice();
         if (GhostOrderSymbol() == a_symbol_0 && GhostOrderMagicNumber() == MagicNumber) {
            if (GhostOrderType() == OP_BUY) {
               RefreshRates();
               li_12 = Close_Order_Attempts;
               is_closed_16 = FALSE;
               while (is_closed_16 == 0 && li_12 >= 0) {
                  li_12--;
                  RefreshRates();
                  ticket_20 = GhostOrderTicket();
               //--- 6: Assert replace OrderClose a buy trade with arrays
                  aCommand[aCount]     = 2; 
                  aClosePrice[aCount]  = NormalizeDouble(Bid, Digits);
                  aCount ++;
                  if( aCount >= MaxAccountTrades ) break;
                  /*is_closed_16 = OrderClose(ticket_20, OrderLots(), NormalizeDouble(Bid, Digits), Slippage, Red);*/
                  if (!TRUE) {
                     error_24 = GetLastError();
                     Print("Forex Envy OrderClose FAILED : Ticket [" + ticket_20 + "]. " + "Error " + error_24 + " [" + ErrorDescription(error_24) + ".]");
                     if (error_24 == 146/* TRADE_CONTEXT_BUSY */) Sleep(50);
                  }
               }
               continue;
            }
            if (GhostOrderType() == OP_SELL) {
               RefreshRates();
               li_12 = Close_Order_Attempts;
               is_closed_16 = FALSE;
               while (is_closed_16 == 0 && li_12 >= 0) {
                  li_12--;
                  RefreshRates();
                  ticket_20 = GhostOrderTicket();
               //--- 6: Assert replace OrderModify a sell trade with arrays
                  aCommand[aCount]     = 4; 
                  aClosePrice[aCount]  = NormalizeDouble(Ask, Digits);
                  aCount ++;
                  if( aCount >= MaxAccountTrades ) break;
                  /*is_closed_16 = OrderClose(ticket_20, OrderLots(), NormalizeDouble(Ask, Digits), Slippage, Green);*/
                  if (!TRUE) {
                     error_24 = GetLastError();
                     Print("Forex Envy OrderClose FAILED : Ticket [" + ticket_20 + "]. " + "Error " + error_24 + " [" + ErrorDescription(error_24) + ".]");
                     if (error_24 == 146/* TRADE_CONTEXT_BUSY */) Sleep(50);
                  }
               }
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #14
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
         case 2:  // OrderClose Buy
            GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], Slippage, Red ); 
            break;
         case 3:  // OrderModify Sell
         case 4:  // OrderClose Sell
            GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], Slippage, Green ); 
            break;
      }
   }
   return (1);
}

int f0_4() {
   int li_0;
   int li_4;
   int li_8;
   int li_12;
   if (DayOfWeek() == 0) {
      li_0 = SUN_StartHour;
      li_4 = SUN_StartMinute;
      li_8 = SUN_EndHour;
      li_12 = SUN_EndMinute;
   }
   if (DayOfWeek() == 1) {
      li_0 = MON_StartHour;
      li_4 = MON_StartMinute;
      li_8 = MON_EndHour;
      li_12 = MON_EndMinute;
   }
   if (DayOfWeek() == 2) {
      li_0 = TUE_StartHour;
      li_4 = TUE_StartMinute;
      li_8 = TUE_EndHour;
      li_12 = TUE_EndMinute;
   }
   if (DayOfWeek() == 3) {
      li_0 = WED_StartHour;
      li_4 = WED_StartMinute;
      li_8 = WED_EndHour;
      li_12 = WED_EndMinute;
   }
   if (DayOfWeek() == 4) {
      li_0 = THU_StartHour;
      li_4 = THU_StartMinute;
      li_8 = THU_EndHour;
      li_12 = THU_EndMinute;
   }
   if (DayOfWeek() == 5) {
      li_0 = FRI_StartHour;
      li_4 = FRI_StartMinute;
      li_8 = FRI_EndHour;
      li_12 = FRI_EndMinute;
   }
   if (DayOfWeek() == 6) {
      li_0 = SAT_StartHour;
      li_4 = SAT_StartMinute;
      li_8 = SAT_EndHour;
      li_12 = SAT_EndMinute;
   }
   int li_16 = 60 * TimeHour(TimeCurrent()) + TimeMinute(TimeCurrent());
   int li_20 = 60 * li_0 + li_4;
   int li_24 = 60 * li_8 + li_12;
   if (li_20 == li_24) return (0);
   if (li_20 < li_24) {
      if (!(!(li_16 >= li_20 && li_16 < li_24))) return (1);
      return (0);
   }
   if (li_20 > li_24) {
      if (!(!(li_16 >= li_20 || li_16 < li_24))) return (1);
      return (0);
   }
   return (0);
}

int start() {
   double order_takeprofit_0;
   double ld_8;
   double ld_16;
   double order_takeprofit_44;
   int li_52;
   bool bool_56;
   f0_8();
   if (IsTesting()) {
      if (Period() != PERIOD_M30) {
         Print("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
         Alert("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
         return (0);
      }
   } else {
      if (Period() != PERIOD_M30) {
         Print("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
         Alert("ERROR -- Forex Envy should be attached to " + Symbol() + " 30 minute chart window");
         return (0);
      }
   }
   if (gi_960 == TRUE) {
      ChickenOutClose(Symbol());
      return (0);
   }
   if (FreezeAfterTPScheduler == TRUE) gi_956 = f0_4();
   gsa_92[0] = GhostAccountNumber();
   gsa_92[1] = KEY;
   gsa_92[2] = User;
   gsa_92[3] = gs_168;
   gi_76 = fun1(gsa_92, ArraySize(gsa_92), 0.2, gs_1172, IsDemo());
   if (gs_1124 != "approved" || gi_76 == 0) {
      Comment("Access denied!", 
      "\nPlease input valid KEY and User into the EA parameters or contact forexenvy.com for support");
      return (0);
   }
   int count_24 = 0;
   int count_28 = 0;
//--- Assert 2: Init OrderSelect #15
   int total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_32 = 0; pos_32 < total; pos_32++) {
      if (GhostOrderSelect(pos_32, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               if (GhostOrderType() == OP_BUY) {
                  count_24++;
                  continue;
               }
               if (GhostOrderType() == OP_SELL) count_28++;
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #15
   GhostFreeSelect(false);
   if (count_24 >= gi_1068) {
      if (!gi_1144) {
         f0_16("Allow long hedge! trades=" + count_24 + ",TradesDeep=" + gi_1068);
         gi_1144 = TRUE;
      }
   }
   if (count_28 >= gi_1068) {
      if (!gi_1140) {
         f0_16("Allow short hedge! trades=" + count_28 + ",TradesDeep=" + gi_1068);
         gi_1140 = TRUE;
      }
   }
   bool li_36 = FALSE;
   if ((100 - BailOutPct) * GhostAccountBalance() / 100.0 >= GhostAccountEquity()) {
      f0_16("AccountBalance=" + GhostAccountBalance() + ",AccountEquity=" + GhostAccountEquity());
      gi_1024 = TRUE;
      li_36 = TRUE;
   }
   if ((gd_1004 + 100.0) * GhostAccountBalance() / 100.0 <= GhostAccountEquity()) gi_1024 = TRUE;
   if (gi_1024) {
   //--- Assert 6: Declare variables
      int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
      int      aTicket[];
      double   aLots[];
      double   aClosePrice[];
      bool     aOk[];
      int      aCount;
   //--- Assert 5: Dynamically resize arrays
      ArrayResize(aCommand,MaxAccountTrades);
      ArrayResize(aTicket,MaxAccountTrades);
      ArrayResize(aLots,MaxAccountTrades);
      ArrayResize(aClosePrice,MaxAccountTrades);
      ArrayResize(aOk,MaxAccountTrades);
   //--- Assert 2: Init OrderSelect #16
      int      aTotal = GhostOrdersTotal();
      GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
      for (int pos_40 = aTotal - 1; pos_40 >= 0; pos_40--) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS)) {
         //--- Assert 5: Populate arrays
            aCommand[aCount]     =  2;
            aTicket[aCount]      =  GhostOrderTicket();
            aLots[aCount]        =  GhostOrderLots();
            aClosePrice[aCount]  =  GhostOrderClosePrice();
            if (GhostOrderMagicNumber() == MagicNumber) {
               f0_16("close #" + GhostOrderTicket());
            //--- 6: Assert replace OrderClose a buy trade with arrays
               aCommand[aCount]     = 2; 
               aClosePrice[aCount]  = NormalizeDouble(Bid, Digits);
               aCount ++;
               if( aCount >= MaxAccountTrades ) break;
               /*if (!OrderClose(OrderTicket(), OrderLots(), OrderClosePrice(), MarketInfo(Symbol(), MODE_SPREAD), White)) {
                  f0_16("error");
                  return (0);
               }*/
            }
         }
      }
   //--- Assert 1: Free OrderSelect #16
      GhostFreeSelect(false);
   //--- Assert for: process array of commands
      for(int i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 1:  // OrderModify Buy
            case 2:  // OrderClose Buy
               GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], MarketInfo(Symbol(), MODE_SPREAD), White ); 
               break;
            case 3:  // OrderModify Sell
            case 4:  // OrderClose Sell
               break;
         }
      }
      gi_1024 = FALSE;
      if (li_36) {
         Sleep(1000 * gi_1012);
         li_36 = FALSE;
      }
      gi_1144 = FALSE;
      gi_1140 = FALSE;
   }
   if (SupportECN) {
      order_takeprofit_0 = 0;
   //--- Assert 1: Init OrderSelect #17
      GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
      if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) order_takeprofit_0 = GhostOrderTakeProfit();
   //--- Assert 1: Free OrderSelect #17
      GhostFreeSelect(false);
   //--- Assert 7: Declare variables
      int      bCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
      int      bTicket[];
      double   bOpenPrice[];
      double   bStopLoss[];
      double   bTakeProfit[];
      bool     bOk[];
      int      bCount;
   //--- Assert 6: Dynamically resize arrays
      ArrayResize(bCommand,MaxAccountTrades);
      ArrayResize(bTicket,MaxAccountTrades);
      ArrayResize(bOpenPrice,MaxAccountTrades);
      ArrayResize(bStopLoss,MaxAccountTrades);
      ArrayResize(bTakeProfit,MaxAccountTrades);
      ArrayResize(bOk,MaxAccountTrades);
   //--- Assert 2: Init OrderSelect #18
      int   bTotal = GhostOrdersTotal();
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      for (pos_40 = 0; pos_40 < bTotal; pos_40++) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS)) {
         //--- Assert 5: Populate arrays
            bCommand[aCount]     =  0;
            bTicket[aCount]      =  GhostOrderTicket();
            bOpenPrice[aCount]   =  GhostOrderOpenPrice();
            bStopLoss[aCount]    =  GhostOrderStopLoss();
            bTakeProfit[aCount]  =  GhostOrderTakeProfit();
            if (GhostOrderMagicNumber() == MagicNumber) {
               order_takeprofit_44 = GhostOrderTakeProfit();
               if (order_takeprofit_44 == 0.0 && StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
                  if (GhostOrderType() == OP_BUY) {
                     if (count_24 > 0) {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24 - 1, Point, gda_1196, count_24 - 1, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     } else {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     }
                     li_52 = Close_Order_Attempts;
                     bool_56 = FALSE;
                     while (bool_56 == FALSE && li_52 >= 0) {
                        li_52--;
                        RefreshRates();
                     //--- 6: Assert replace OrderModify a buy trade with arrays
                        bCommand[aCount]     = 1; 
                        bOpenPrice[aCount]   = 0;
                        bStopLoss[aCount]    = NormalizeDouble(GhostOrderStopLoss(), Digits);
                        bTakeProfit[aCount]  = NormalizeDouble(GhostOrderOpenPrice() + g_pips_972 * Point, Digits);
                        bCount ++;
                        if( bCount >= MaxAccountTrades ) break;
                        /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(OrderStopLoss(), Digits), NormalizeDouble(OrderOpenPrice() + g_pips_972 * Point, Digits), 0, White);*/
                        if (!TRUE) {
                           g_error_1248 = GetLastError();
                           if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                              Sleep(50);
                              continue;
                           }
                        }
                        bool_56 = TRUE;
                     }
                  } else {
                     if (GhostOrderType() != OP_SELL) continue;
                     if (count_28 > 0) {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28 - 1, Point, gda_1196, count_28 - 1, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     } else {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     }
                     li_52 = Close_Order_Attempts;
                     bool_56 = FALSE;
                     while (bool_56 == FALSE && li_52 >= 0) {
                        li_52--;
                        RefreshRates();
                     //--- 6: Assert replace OrderModify a sell trade with arrays
                        bCommand[aCount]     = 3; 
                        bOpenPrice[aCount]   = 0;
                        bStopLoss[aCount]    = NormalizeDouble(GhostOrderStopLoss(), Digits);
                        bTakeProfit[aCount]  = NormalizeDouble(GhostOrderOpenPrice() - g_pips_972 * Point, Digits);
                        bCount ++;
                        if( bCount >= MaxAccountTrades ) break;
                        /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(OrderStopLoss(), Digits), NormalizeDouble(OrderOpenPrice() - g_pips_972 * Point, Digits), 0, White);*/
                        if (!TRUE) {
                           g_error_1248 = GetLastError();
                           if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                              Sleep(50);
                              continue;
                           }
                        }
                        bool_56 = TRUE;
                     }
                     continue;
                  }
               }
               if (StringFind(GhostOrderComment(), gs__hedged_1156) != -1 && g_cmd_1152 == GhostOrderType()) {
                  ld_8 = order_takeprofit_0 - MarketInfo(Symbol(), MODE_SPREAD) * Point;
                  ld_16 = order_takeprofit_0 + MarketInfo(Symbol(), MODE_SPREAD) * Point;
                  if (GhostOrderStopLoss() == 0.0 || (GhostOrderType() == OP_BUY && GhostOrderStopLoss() != ld_8) || (GhostOrderType() == OP_SELL && GhostOrderStopLoss() != ld_16)) {
                     if (GhostOrderType() == OP_BUY) {
                        li_52 = Close_Order_Attempts;
                        bool_56 = FALSE;
                        while (bool_56 == FALSE && li_52 >= 0) {
                           li_52--;
                           RefreshRates();
                        //--- 6: Assert replace OrderModify a buy trade with arrays
                           bCommand[aCount]     = 1; 
                           bOpenPrice[aCount]   = 0;
                           bStopLoss[aCount]    = NormalizeDouble(ld_8, Digits);
                           bTakeProfit[aCount]  = NormalizeDouble(GhostOrderTakeProfit(), Digits);
                           bCount ++;
                           if( bCount >= MaxAccountTrades ) break;
                           /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(ld_8, Digits), NormalizeDouble(OrderTakeProfit(), Digits), 0, White);*/
                           if (!TRUE) {
                              g_error_1248 = GetLastError();
                              if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                                 Sleep(50);
                                 continue;
                              }
                           }
                           bool_56 = TRUE;
                        }
                        continue;
                     }
                     if (GhostOrderType() == OP_SELL) {
                        li_52 = Close_Order_Attempts;
                        bool_56 = FALSE;
                        while (bool_56 == FALSE && li_52 >= 0) {
                           li_52--;
                           RefreshRates();
                        //--- 6: Assert replace OrderModify a sell trade with arrays
                           bCommand[aCount]     = 3; 
                           bOpenPrice[aCount]   = 0;
                           bStopLoss[aCount]    = NormalizeDouble(ld_16, Digits);
                           bTakeProfit[aCount]  = NormalizeDouble(GhostOrderTakeProfit(), Digits);
                           bCount ++;
                           if( bCount >= MaxAccountTrades ) break;
                           /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(ld_16, Digits), NormalizeDouble(OrderTakeProfit(), Digits), 0, White);*/
                           if (!TRUE) {
                              g_error_1248 = GetLastError();
                              if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                                 Sleep(50);
                                 continue;
                              }
                           }
                           bool_56 = TRUE;
                        }
                     }
                  }
               }
            }
         }
      }
   //--- Assert 1: Free OrderSelect #18
      GhostFreeSelect(true);
   //--- Assert for: process array of commands
      for(i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 1:  // OrderModify Buy
               GhostOrderModify( bTicket[i], bOpenPrice[i], bStopLoss[i], bTakeProfit[i], 0, White ); 
               break;
            case 2:  // OrderClose Buy
            case 3:  // OrderModify Sell
               GhostOrderModify( bTicket[i], bOpenPrice[i], bStopLoss[i], bTakeProfit[i], 0, White ); 
               break;
            case 4:  // OrderClose Sell
               break;
         }
      }
   }
//--- Assert 2: Refresh Plus   
   GhostRefresh();
   if (f0_0() != 0) {
      gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      f0_15(count_24, count_28);
      gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      f0_14(count_24, count_28);
      gi_1200 = fun0(gda_1180, gda_1184, Digits, 0, Point, gda_1196, 0, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      if ((!FreezeAfterTP) && !gi_956) {
         if (gi_1136) {
            gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
            if (gi_1200 >= 0) {
               g_pips_972 = gda_1196[0];
               gd_1076 = gda_1196[1];
               gd_964 = gda_1196[2];
               if (gi_1200 == 0) gi_1168 = FALSE;
               else gi_1168 = TRUE;
            }
            if (f0_12(1)) gi_1136 = FALSE;
         }
         if (gi_1132) {
            gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
            if (gi_1200 >= 0) {
               g_pips_972 = gda_1196[0];
               gd_1076 = gda_1196[1];
               gd_964 = gda_1196[2];
               if (gi_1200 == 0) gi_1168 = FALSE;
               else gi_1168 = TRUE;
            }
            if (f0_13(1)) gi_1132 = FALSE;
         }
      }
      f0_17();
      return (0);
   }
   return (0);
}

void f0_17() {
   string dbl2str_0 = DoubleToStr(f0_1(2), 2);
   if (!IsTesting()) f0_10();
   if (FreezeAfterTPScheduler == TRUE && f0_4() == 1) {
      Comment( GhostComment(" \nForex Envy v2.1" + 
         "\nAccount Leverage  :  " + "1 : " + AccountLeverage() + 
         "\nAccount Type  :  " + AccountServer() + 
         "\nServer Time  :  " + TimeToStr(TimeCurrent(), TIME_SECONDS) +
         "\nAccount Equity  = " + GhostAccountEquity() +
         "\nFree Margin     = " + GhostAccountFreeMargin() +
         "\nDrawdown  :  " + dbl2str_0 + "%" +
         "\nTotal Profit/Loss = " + gd_948 +
         "\nFreezeAfterTPScheduler: ON" +
      "\n\n") );
      return;
   }
   Comment( GhostComment(" \nForex Envy v2.1" +
      "\nAccount Leverage  :  " + "1 : " + AccountLeverage() +
      "\nAccount Type  :  " + AccountServer() +
      "\nServer Time  :  " + TimeToStr(TimeCurrent(), TIME_SECONDS) +
      "\nAccount Equity  = " + GhostAccountEquity() +
      "\nFree Margin     = " + GhostAccountFreeMargin() +
      "\nDrawdown  :  " + dbl2str_0 + "%" +
      "\nTotal Profit/Loss = " + gd_948 +
      "\nFreezeAfterTPScheduler: OFF" +
   "\n\n") );
}

int f0_0() {
   return (1);
}

double f0_1(int ai_0) {
   double ld_ret_4;
   if (ai_0 == 2) {
      ld_ret_4 = (GhostAccountEquity() / GhostAccountBalance() - 1.0) / (-0.010000000000000000208);
      if (ld_ret_4 <= 0.0) return (0);
      return (ld_ret_4);
   }
   if (ai_0 == 1) {
      ld_ret_4 = 100.0 * (GhostAccountEquity() / GhostAccountBalance() - 1.0);
      if (ld_ret_4 <= 0.0) return (0);
      return (ld_ret_4);
   }
   return (0.0);
}
